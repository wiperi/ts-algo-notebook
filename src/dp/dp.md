# 动态规划

## 代码框架

```py
# 自顶向下递归的动态规划

def problem(...):

    def dp(状态1, 状态2, ...):

        for 选择 in 所有可能的选择:
            # 此时的状态已经因为做了选择而改变
            result = min(result, dp(状态1, 状态2, ...))

        return result

    return dp(...)
```

```py
# 自底向上迭代的动态规划

def problem():
    # 初始化 base case
    dp[0][0][...] = base case

    # 进行状态转移
    for 状态1 in 状态1的所有取值：
        for 状态2 in 状态2的所有取值：
            for ...
                dp[状态1][状态2][...] = min(选择1，选择2...)
```

## 动态规划的要素

动态规划是分治算法的延申，都是通过组合子问题的解来求解原问题，而动态规划常常用在 **求最值** 问题上

Dynamic Programmin中的Programming指的是一种表格法，即利用表格记录子问题的解，来做到对重叠子问题的性能优化

简而言之，动态规划就是穷举求最值

**动态规划的三要素** 

 - 最优子结构：可以通过子问题的解，找到原问题的解，且子问题之间互不干扰 ie 子问题的解不会影响同层其他子问题的解

 - 状态转移方程：原问题应该如何拆分成子问题

 - 重叠子问题：用备忘录如memo，dp table来避免对子问题的重复计算

**解决问题的步骤**

 - 识别是否具有最优子结构
 - 找到状态转移方程
 - 定义状态，选择，dp函数/数组的含义
 - 构建dp table，通常使用自底向上方法

dp函数和数组的相同之处，函数和数组本质都是映射关系，函数是 参数 -> 返回值，数组是 索引 -> 值。

```python
def f(n):
    if n in range(3):
        return n * 10


arr = [0, 20, 30]

# f(x) == arr[x]
```

## 动态规划的递归树

![Dynamic Programming](/assets//dp-recursion-tree.png)

递归树上每个节点对应一次函数调用，都有状态和选择空间，状态明确了当前问题的状态，ie.求第n个Fibonacci数，状态和节点一一对应，所以状态要么在函数的参数中，要么在全局维护的的栈结构中

每个节点都有选择空间，定义当前节点要做出哪些选择，当前状态 + 选择 = 子节点的新状态

之所以能使用数组自底向上的计算，因为 **问题的每个状态都对应唯一返回值，父节点的返回值由子节点的返回值们决定，常常是由最大or最小的子节点返回值决定** 

而回溯算法关注找到合法的路径，而不是节点的返回值

